<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#075e54">
  <meta name="description" content="WhatsApp sohbet g√∂r√ºnt√ºleyici - Export edilen mesajlarƒ± g√∂r√ºnt√ºleyin">
  <title>WhatsApp Chat Viewer</title>
  <link rel="manifest" href="manifest.json">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    :root {
      --whatsapp-green: #075e54;
      --whatsapp-light-green: #25d366;
      --whatsapp-dark-green: #128c7e;
      --message-sent: #dcf8c6;
      --message-sent-dark: #d9fdd3;
      --message-received: #ffffff;
      --message-received-dark: #202c33;
      --text-primary: #111b21;
      --text-primary-dark: #e9edef;
      --text-secondary: #667781;
      --text-secondary-dark: #8696a0;
      --border-color: #e9edef;
      --border-color-dark: #313d45;
      --bg-primary: #efeae2;
      --bg-primary-dark: #0b141a;
      --bg-secondary: #f0f2f5;
      --bg-secondary-dark: #111b21;
      --avatar-size: 40px;
      --bubble-radius: 7.5px;
      --shadow: 0 1px 0.5px rgba(0,0,0,0.13);
      --shadow-sent: 0 1px 1px rgba(0,0,0,0.1);
      --shadow-received: 0 1px 0.5px rgba(0,0,0,0.13);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .app-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      max-width: 100%;
      margin: 0 auto;
    }

    .header {
      background: var(--whatsapp-green);
      color: white;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .header h1 {
      font-size: 18px;
      font-weight: 500;
    }

    .upload-section {
      background: white;
      padding: 20px;
      margin: 16px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .upload-section.hidden {
      display: none;
    }

    .upload-area {
      border: 2px dashed var(--border-color);
      border-radius: 8px;
      padding: 30px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      background: var(--bg-secondary);
    }

    .upload-area:hover {
      border-color: var(--whatsapp-light-green);
      background: #f8f9fa;
    }

    .upload-area.dragover {
      border-color: var(--whatsapp-light-green);
      background: #e8f5e9;
    }

    .upload-icon {
      font-size: 48px;
      margin-bottom: 12px;
    }

    .upload-text {
      font-size: 16px;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }

    .upload-hint {
      font-size: 14px;
      color: var(--text-secondary);
    }

    .file-input {
      display: none;
    }

    .chat-container {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 16px 8px;
      -webkit-overflow-scrolling: touch;
    }

    .chat-container::-webkit-scrollbar {
      width: 6px;
    }

    .chat-container::-webkit-scrollbar-track {
      background: transparent;
    }

    .chat-container::-webkit-scrollbar-thumb {
      background: rgba(0,0,0,0.2);
      border-radius: 3px;
    }

    .date-separator {
      text-align: center;
      margin: 24px 0;
      position: relative;
    }

    .date-separator::before {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      top: 50%;
      height: 1px;
      background: var(--border-color);
    }

    .date-separator span {
      background: var(--bg-primary);
      padding: 6px 12px;
      border-radius: 12px;
      font-size: 12.5px;
      color: var(--text-secondary);
      position: relative;
      display: inline-block;
    }

    .message-group {
      margin-bottom: 2px;
      display: flex;
      flex-direction: column;
    }

    .message {
      display: flex;
      margin-bottom: 2px;
      padding: 2px 8px;
      animation: fadeIn 0.2s ease-in;
      align-items: flex-end;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .message.sent {
      justify-content: flex-end;
      padding-left: 60px;
    }

    .message.received {
      justify-content: flex-start;
      padding-right: 60px;
    }

    .message-content {
      max-width: 65%;
      min-width: 100px;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    .message.sent .message-content {
      align-items: flex-end;
    }

    .message.received .message-content {
      align-items: flex-start;
    }

    .message-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 2px;
      font-size: 13px;
      padding-left: 4px;
    }

    .message.sent .message-header {
      display: none;
    }

    .message.received .message-header {
      display: flex;
    }

    .avatar {
      width: var(--avatar-size);
      height: var(--avatar-size);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 16px;
      flex-shrink: 0;
      margin-right: 8px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }

    .message.sent .avatar {
      display: none;
    }

    .sender-name {
      font-weight: 600;
      color: var(--text-primary);
    }

    .message-bubble {
      padding: 6px 7px 8px 9px;
      border-radius: var(--bubble-radius);
      word-wrap: break-word;
      position: relative;
      display: inline-block;
    }

    .message.sent .message-bubble {
      background: var(--message-sent);
      border-bottom-right-radius: 2px;
      box-shadow: var(--shadow-sent);
      margin-left: auto;
    }

    .message.received .message-bubble {
      background: var(--message-received);
      border-bottom-left-radius: 2px;
      box-shadow: var(--shadow-received);
    }

    .message-text {
      font-size: 14.2px;
      line-height: 19px;
      color: var(--text-primary);
      white-space: pre-wrap;
    }

    .message-time {
      font-size: 11px;
      color: var(--text-secondary);
      margin-top: 4px;
      text-align: right;
      padding-right: 2px;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 4px;
    }

    .message.received .message-time {
      text-align: left;
      justify-content: flex-start;
    }

    .message-time::before {
      content: '';
      display: inline-block;
      width: 11px;
      height: 11px;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 15' width='16' height='15'%3E%3Cpath fill='%23667781' d='M15.01 3.316l-.478-.372a.365.365 0 0 0-.51.063L8.666 9.879a.32.32 0 0 1-.484.033l-.358-.325a.319.319 0 0 0-.484.032l-.378.483a.418.418 0 0 0 .036.541l1.32 1.266c.143.14.361.125.484-.033l6.272-8.048a.366.366 0 0 0-.063-.51zm-4.1 0l-.478-.372a.365.365 0 0 0-.51.063L4.566 9.879a.32.32 0 0 1-.484.033L1.891 7.769a.366.366 0 0 0-.515.006l-.423.433a.364.364 0 0 0 .006.514l3.258 3.185c.143.14.361.125.484-.033l6.272-8.048a.365.365 0 0 0-.063-.51z'/%3E%3C/svg%3E");
      background-size: contain;
      background-repeat: no-repeat;
      opacity: 0.6;
    }

    .media-container {
      margin: -6px -7px -8px -9px;
      border-radius: var(--bubble-radius);
      overflow: hidden;
      position: relative;
      cursor: pointer;
    }

    .media-container img,
    .media-container video {
      width: 100%;
      height: auto;
      display: block;
      max-height: 300px;
      object-fit: cover;
    }

    .media-thumbnail {
      width: 100%;
      height: 200px;
      object-fit: cover;
      background: #f0f0f0;
    }

    .media-placeholder {
      width: 100%;
      height: 200px;
      background: var(--bg-secondary);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-secondary);
      font-size: 14px;
    }

    .audio-player-container {
      padding: 12px;
      background: rgba(0,0,0,0.05);
    }

    .audio-player {
      width: 100%;
      height: 32px;
    }

    .document-link {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: rgba(0,0,0,0.05);
      text-decoration: none;
      color: var(--text-primary);
    }

    .document-icon {
      font-size: 32px;
    }

    .document-info {
      flex: 1;
    }

    .document-name {
      font-weight: 500;
      font-size: 14px;
      margin-bottom: 2px;
    }

    .document-size {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .media-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.95);
      z-index: 1000;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      touch-action: pan-y pinch-zoom;
    }

    .media-modal.active {
      display: flex;
    }

    .media-modal-content {
      max-width: 100%;
      max-height: 100%;
      position: relative;
      touch-action: pan-y pinch-zoom;
    }

    .media-modal-content img,
    .media-modal-content video {
      max-width: 100vw;
      max-height: 100vh;
      object-fit: contain;
      user-select: none;
      -webkit-user-select: none;
    }

    .media-modal-close {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0,0,0,0.5);
      color: white;
      border: none;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1001;
      touch-action: manipulation;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: var(--text-secondary);
    }

    .error {
      background: #ffebee;
      color: #c62828;
      padding: 12px 16px;
      border-radius: 8px;
      margin: 16px;
      font-size: 14px;
      white-space: pre-wrap;
      word-wrap: break-word;
      max-height: 300px;
      overflow-y: auto;
    }

    .stats {
      background: white;
      padding: 12px 16px;
      margin: 0 16px 16px;
      border-radius: 8px;
      font-size: 14px;
      color: var(--text-secondary);
      display: flex;
      justify-content: space-between;
    }

    .stats.hidden {
      display: none;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --message-sent: #005c4b;
        --message-received: #202c33;
        --text-primary: #e9edef;
        --text-secondary: #8696a0;
        --border-color: #313d45;
        --bg-primary: #0b141a;
        --bg-secondary: #111b21;
      }
    }

    @media (max-width: 768px) {
      .message-content {
        max-width: 85%;
      }

      .upload-section {
        margin: 8px;
        padding: 16px;
      }

      .chat-container {
        padding: 8px 4px;
      }
    }

    .virtual-scroll-spacer {
      height: 1px;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <div class="header">
      <h1>WhatsApp Chat Viewer</h1>
    </div>

    <div class="upload-section" id="uploadSection">
      <div class="upload-area" id="uploadArea">
        <div class="upload-icon">üìÅ</div>
        <div class="upload-text">WhatsApp Export Dosyasƒ±nƒ± Y√ºkleyin</div>
        <div class="upload-hint">.zip dosyasƒ±, klas√∂r veya sohbet dosyasƒ± + medya klas√∂r√º se√ßin</div>
        <input type="file" id="fileInput" class="file-input" accept=".zip,.txt,.json,.csv,.xml,.text" />
        <input type="file" id="folderInput" class="file-input" webkitdirectory directory multiple style="display:none;" />
        <input type="file" id="txtFileInput" class="file-input" accept=".txt,.json,.csv,.xml,.text" style="display:none;" />
        <input type="file" id="mediaFileInput" class="file-input" webkitdirectory directory multiple style="display:none;" />
      </div>
    </div>

    <div class="stats hidden" id="stats">
      <span>Mesajlar: <strong id="messageCount">0</strong></span>
      <span>Medya: <strong id="mediaCount">0</strong></span>
    </div>

    <div class="error hidden" id="error"></div>

    <div class="chat-container" id="chatContainer">
      <div class="loading" id="loading">Dosya y√ºkleniyor...</div>
    </div>

    <div class="media-modal" id="mediaModal">
      <button class="media-modal-close" id="modalClose">√ó</button>
      <div class="media-modal-content" id="modalContent"></div>
    </div>
  </div>

  <script>
    // ==================== UTILITY FUNCTIONS ====================
    const Utils = {
      formatDate(date) {
        const today = new Date();
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);
        
        if (date.toDateString() === today.toDateString()) {
          return 'Bug√ºn';
        } else if (date.toDateString() === yesterday.toDateString()) {
          return 'D√ºn';
        } else {
          const months = ['Ocak', '≈ûubat', 'Mart', 'Nisan', 'Mayƒ±s', 'Haziran', 
                         'Temmuz', 'Aƒüustos', 'Eyl√ºl', 'Ekim', 'Kasƒ±m', 'Aralƒ±k'];
          return `${date.getDate()} ${months[date.getMonth()]} ${date.getFullYear()}`;
        }
      },

      formatTime(date) {
        return date.toLocaleTimeString('tr-TR', { hour: '2-digit', minute: '2-digit' });
      },

      getAvatarColor(name) {
        const colors = [
          '#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b',
          '#eb4d4b', '#6c5ce7', '#a29bfe', '#fd79a8', '#00b894'
        ];
        let hash = 0;
        for (let i = 0; i < name.length; i++) {
          hash = name.charCodeAt(i) + ((hash << 5) - hash);
        }
        return colors[Math.abs(hash) % colors.length];
      },

      getInitials(name) {
        return name.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2);
      },

      debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
    };

    // ==================== WHATSAPP PARSER ====================
    const WhatsAppParser = {
      parse(text) {
        const messages = [];
        const lines = text.split('\n');
        let currentMessage = null;

        // WhatsApp export formatlarƒ± (farklƒ± diller ve formatlar):
        // [DD.MM.YY, SS:DD] ƒ∞sim: Mesaj
        // DD/MM/YY, SS:DD - ƒ∞sim: Mesaj
        // [MM/DD/YY HH:MM:SS] ƒ∞sim: Mesaj (ABD formatƒ±, saniye ile)
        // [DD.MM.YYYY, SS:DD] ƒ∞sim: Mesaj
        // DD/MM/YYYY, SS:DD - ƒ∞sim: Mesaj
        // [DD-MM-YY, SS:DD] ƒ∞sim: Mesaj
        // DD-MM-YY, SS:DD - ƒ∞sim: Mesaj
        // [YYYY-MM-DD, SS:DD] ƒ∞sim: Mesaj
        const patterns = [
          // [MM/DD/YY HH:MM:SS] ƒ∞sim: Mesaj (ABD formatƒ±, saniye ile) - √ñNCE BU KONTROL EDƒ∞LSƒ∞N
          /^\[(\d{1,2})\/(\d{1,2})\/(\d{2,4})\s+(\d{1,2}):(\d{2}):(\d{2})\]\s*(.+?):\s*(.+)$/,
          // [MM/DD/YY HH:MM] ƒ∞sim: Mesaj (ABD formatƒ±, saniye olmadan)
          /^\[(\d{1,2})\/(\d{1,2})\/(\d{2,4})\s+(\d{1,2}):(\d{2})\]\s*(.+?):\s*(.+)$/,
          // [DD.MM.YY, SS:DD] ƒ∞sim: Mesaj
          /^\[(\d{1,2})\.(\d{1,2})\.(\d{2,4}),\s*(\d{1,2}):(\d{2})\]\s*(.+?):\s*(.+)$/,
          // DD/MM/YY, SS:DD - ƒ∞sim: Mesaj
          /^(\d{1,2})\/(\d{1,2})\/(\d{2,4}),\s*(\d{1,2}):(\d{2})\s*-\s*(.+?):\s*(.+)$/,
          // [DD-MM-YY, SS:DD] ƒ∞sim: Mesaj
          /^\[(\d{1,2})-(\d{1,2})-(\d{2,4}),\s*(\d{1,2}):(\d{2})\]\s*(.+?):\s*(.+)$/,
          // DD-MM-YY, SS:DD - ƒ∞sim: Mesaj
          /^(\d{1,2})-(\d{1,2})-(\d{2,4}),\s*(\d{1,2}):(\d{2})\s*-\s*(.+?):\s*(.+)$/,
          // [YYYY-MM-DD, SS:DD] ƒ∞sim: Mesaj
          /^\[(\d{4})-(\d{1,2})-(\d{1,2}),\s*(\d{1,2}):(\d{2})\]\s*(.+?):\s*(.+)$/,
          // YYYY-MM-DD, SS:DD - ƒ∞sim: Mesaj
          /^(\d{4})-(\d{1,2})-(\d{1,2}),\s*(\d{1,2}):(\d{2})\s*-\s*(.+?):\s*(.+)$/,
          // [DD.MM.YYYY, SS:DD] ƒ∞sim: Mesaj (4 haneli yƒ±l)
          /^\[(\d{1,2})\.(\d{1,2})\.(\d{4}),\s*(\d{1,2}):(\d{2})\]\s*(.+?):\s*(.+)$/,
          // DD/MM/YYYY, SS:DD - ƒ∞sim: Mesaj (4 haneli yƒ±l)
          /^(\d{1,2})\/(\d{1,2})\/(\d{4}),\s*(\d{1,2}):(\d{2})\s*-\s*(.+?):\s*(.+)$/
        ];

        let matchedCount = 0;
        let sampleLines = [];

        for (let i = 0; i < lines.length; i++) {
          let line = lines[i].trim();
          if (!line) continue;

          // ƒ∞lk 5 satƒ±rƒ± √∂rnek olarak sakla (debug i√ßin)
          if (i < 5 && line.length > 0) {
            sampleLines.push(line);
          }

          let matched = false;
          for (let patternIndex = 0; patternIndex < patterns.length; patternIndex++) {
            const pattern = patterns[patternIndex];
            const match = line.match(pattern);
            if (match) {
              matched = true;
              matchedCount++;
              const groups = match;
              
              let day, month, year, hour, minute, sender, text;
              
              // Pattern tipine g√∂re parse et
              if (patternIndex === 0) {
                // [MM/DD/YY HH:MM:SS] format (ABD formatƒ±, saniye ile)
                month = parseInt(groups[1]) - 1; // MM (ay)
                day = parseInt(groups[2]);      // DD (g√ºn)
                year = parseInt(groups[3]);      // YY
                if (year < 100) year += 2000;
                hour = parseInt(groups[4]);
                minute = parseInt(groups[5]);
                // groups[6] saniye, kullanmƒ±yoruz
                sender = groups[7].trim();
                text = groups[8];
              } else if (patternIndex === 1) {
                // [MM/DD/YY HH:MM] format (ABD formatƒ±, saniye olmadan)
                month = parseInt(groups[1]) - 1; // MM (ay)
                day = parseInt(groups[2]);      // DD (g√ºn)
                year = parseInt(groups[3]);      // YY
                if (year < 100) year += 2000;
                hour = parseInt(groups[4]);
                minute = parseInt(groups[5]);
                sender = groups[6].trim();
                text = groups[7];
              } else if (patternIndex === 2 || patternIndex === 8) {
                // [DD.MM.YY/YYYY, SS:DD] format
                day = parseInt(groups[1]);
                month = parseInt(groups[2]) - 1;
                year = parseInt(groups[3]);
                if (year < 100) year += 2000;
                hour = parseInt(groups[4]);
                minute = parseInt(groups[5]);
                sender = groups[6].trim();
                text = groups[7];
              } else if (patternIndex === 3 || patternIndex === 9) {
                // DD/MM/YY/YYYY, SS:DD - format
                day = parseInt(groups[1]);
                month = parseInt(groups[2]) - 1;
                year = parseInt(groups[3]);
                if (year < 100) year += 2000;
                hour = parseInt(groups[4]);
                minute = parseInt(groups[5]);
                sender = groups[6].trim();
                text = groups[7];
              } else if (patternIndex === 4 || patternIndex === 5) {
                // [DD-MM-YY, SS:DD] veya DD-MM-YY, SS:DD - format
                day = parseInt(groups[1]);
                month = parseInt(groups[2]) - 1;
                year = parseInt(groups[3]);
                if (year < 100) year += 2000;
                hour = parseInt(groups[4]);
                minute = parseInt(groups[5]);
                sender = groups[6].trim();
                text = groups[7];
              } else if (patternIndex === 6 || patternIndex === 7) {
                // [YYYY-MM-DD, SS:DD] veya YYYY-MM-DD, SS:DD - format
                year = parseInt(groups[1]);
                month = parseInt(groups[2]) - 1;
                day = parseInt(groups[3]);
                hour = parseInt(groups[4]);
                minute = parseInt(groups[5]);
                sender = groups[6].trim();
                text = groups[7];
              }

              const date = new Date(year, month, day, hour, minute);
              
              // Ge√ßersiz tarih kontrol√º
              if (isNaN(date.getTime())) {
                continue;
              }
              
              // √ñnceki mesajƒ± kaydet
              if (currentMessage) {
                messages.push(currentMessage);
              }

              // Yeni mesaj olu≈ütur
              currentMessage = {
                date,
                sender,
                text: text.trim(),
                media: null,
                isMedia: false
              };

              // Medya kontrol√º (farklƒ± diller ve formatlar i√ßin)
              const mediaPatterns = [
                // <DOSYA_ADI eklendi> formatƒ± (T√ºrk√ße WhatsApp)
                /<([^>]+?)\s+eklendi>/i,
                // <attached: DOSYA_ADI> formatƒ±
                /<attached:\s*(.+?)>/i,
                // <DOSYA_ADI attached> formatƒ±
                /<([^>]+?)\s+attached>/i,
                // image/video/audio/document omitted
                /image omitted/i,
                /video omitted/i,
                /audio omitted/i,
                /document omitted/i,
                // T√ºrk√ße
                /resim atlandƒ±/i,
                /video atlandƒ±/i,
                /ses atlandƒ±/i,
                /belge atlandƒ±/i,
                // ƒ∞spanyolca
                /imagen omitida/i,
                /video omitido/i,
                /audio omitido/i,
                /documento omitido/i
              ];
              
              for (let mediaPattern of mediaPatterns) {
                const mediaMatch = text.match(mediaPattern);
                if (mediaMatch) {
                  currentMessage.isMedia = true;
                  // ƒ∞lk capture group'u al (dosya adƒ±)
                  const fileName = mediaMatch[1] || mediaMatch[0];
                  if (fileName && fileName !== 'image' && fileName !== 'video' && fileName !== 'audio' && fileName !== 'document') {
                    // Dosya adƒ±nƒ± temizle (eklendi, attached gibi kelimeleri kaldƒ±r)
                    currentMessage.media = fileName.trim().replace(/\s+(eklendi|attached)$/i, '');
                  } else {
                    currentMessage.media = 'unknown';
                  }
                  break;
                }
              }

              break;
            }
          }

          // Eƒüer pattern e≈üle≈ümediyse, √∂nceki mesajƒ±n devamƒ± olabilir
          if (!matched && currentMessage) {
            currentMessage.text += '\n' + line;
          }
        }

        // Son mesajƒ± ekle
        if (currentMessage) {
          messages.push(currentMessage);
        }

        // Debug bilgisi
        if (messages.length === 0 && sampleLines.length > 0) {
          console.log('Parser Debug - √ñrnek satƒ±rlar:', sampleLines);
          console.log('Parser Debug - E≈üle≈üen mesaj sayƒ±sƒ±:', matchedCount);
        }

        return { messages, sampleLines, matchedCount };
      }
    };

    // ==================== INDEXEDDB STORAGE ====================
    const Storage = {
      db: null,
      dbName: 'WhatsAppChatViewer',
      dbVersion: 1,

      async init() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, this.dbVersion);

          request.onerror = () => reject(request.error);
          request.onsuccess = () => {
            this.db = request.result;
            resolve();
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            
            if (!db.objectStoreNames.contains('media')) {
              const mediaStore = db.createObjectStore('media', { keyPath: 'name' });
              mediaStore.createIndex('type', 'type', { unique: false });
            }

            if (!db.objectStoreNames.contains('messages')) {
              db.createObjectStore('messages', { keyPath: 'id', autoIncrement: true });
            }
          };
        });
      },

      async saveMedia(name, blob, type) {
        if (!this.db) await this.init();
        
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction(['media'], 'readwrite');
          const store = transaction.objectStore('media');
          const request = store.put({ name, blob, type, timestamp: Date.now() });
          
          request.onsuccess = () => resolve();
          request.onerror = () => reject(request.error);
        });
      },

      async getMedia(name) {
        if (!this.db) await this.init();
        
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction(['media'], 'readonly');
          const store = transaction.objectStore('media');
          const request = store.get(name);
          
          request.onsuccess = () => {
            const result = request.result;
            resolve(result ? result.blob : null);
          };
          request.onerror = () => reject(request.error);
        });
      },

      async getAllMediaNames() {
        if (!this.db) await this.init();
        
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction(['media'], 'readonly');
          const store = transaction.objectStore('media');
          const request = store.getAll();
          
          request.onsuccess = () => {
            const names = request.result.map(r => r.name);
            resolve(names);
          };
          request.onerror = () => reject(request.error);
        });
      }
    };

    // ==================== MEDIA VIEWER ====================
    const MediaViewer = {
      modal: null,
      modalContent: null,
      closeButton: null,
      touchStartX: 0,
      touchStartY: 0,
      currentScale: 1,
      currentTranslateX: 0,
      currentTranslateY: 0,

      init() {
        this.modal = document.getElementById('mediaModal');
        this.modalContent = document.getElementById('modalContent');
        this.closeButton = document.getElementById('modalClose');

        this.closeButton.addEventListener('click', () => this.close());
        this.modal.addEventListener('click', (e) => {
          if (e.target === this.modal) this.close();
        });

        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') this.close();
        });

        // Touch gesture desteƒüi
        this.setupTouchGestures();
      },

      setupTouchGestures() {
        let initialDistance = 0;
        let initialScale = 1;

        this.modalContent.addEventListener('touchstart', (e) => {
          if (e.touches.length === 1) {
            this.touchStartX = e.touches[0].clientX;
            this.touchStartY = e.touches[0].clientY;
          } else if (e.touches.length === 2) {
            // Pinch zoom
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            initialDistance = Math.hypot(
              touch2.clientX - touch1.clientX,
              touch2.clientY - touch1.clientY
            );
            initialScale = this.currentScale;
          }
        });

        this.modalContent.addEventListener('touchmove', (e) => {
          if (e.touches.length === 2) {
            // Pinch zoom
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const currentDistance = Math.hypot(
              touch2.clientX - touch1.clientX,
              touch2.clientY - touch1.clientY
            );
            const scale = initialScale * (currentDistance / initialDistance);
            this.currentScale = Math.max(1, Math.min(scale, 3));
            
            const img = this.modalContent.querySelector('img');
            if (img) {
              img.style.transform = `scale(${this.currentScale})`;
            }
          }
        });

        this.modalContent.addEventListener('touchend', () => {
          if (this.currentScale < 1.1) {
            this.currentScale = 1;
            const img = this.modalContent.querySelector('img');
            if (img) {
              img.style.transform = 'scale(1)';
            }
          }
        });
      },

      async showMedia(mediaName, type) {
        const blob = await Storage.getMedia(mediaName);
        if (!blob) {
          this.showError('Medya dosyasƒ± bulunamadƒ±');
          return;
        }

        const url = URL.createObjectURL(blob);
        this.modalContent.innerHTML = '';

        if (type.startsWith('image/')) {
          const img = document.createElement('img');
          img.src = url;
          img.style.maxWidth = '100%';
          img.style.maxHeight = '100%';
          this.modalContent.appendChild(img);
        } else if (type.startsWith('video/')) {
          const video = document.createElement('video');
          video.src = url;
          video.controls = true;
          video.style.maxWidth = '100%';
          video.style.maxHeight = '100%';
          this.modalContent.appendChild(video);
        } else if (type.startsWith('audio/')) {
          const audio = document.createElement('audio');
          audio.src = url;
          audio.controls = true;
          audio.style.width = '100%';
          this.modalContent.appendChild(audio);
        } else {
          const link = document.createElement('a');
          link.href = url;
          link.download = mediaName;
          link.textContent = 'ƒ∞ndir: ' + mediaName;
          link.style.color = 'white';
          link.style.padding = '20px';
          this.modalContent.appendChild(link);
        }

        this.modal.classList.add('active');
      },

      close() {
        this.modal.classList.remove('active');
        // URL'leri temizle
        const elements = this.modalContent.querySelectorAll('img, video, audio, a');
        elements.forEach(el => {
          if (el.src) URL.revokeObjectURL(el.src);
          if (el.href) URL.revokeObjectURL(el.href);
        });
        this.modalContent.innerHTML = '';
        // Reset transform
        this.currentScale = 1;
        this.currentTranslateX = 0;
        this.currentTranslateY = 0;
      },

      showError(message) {
        alert(message);
      }
    };

    // ==================== CHAT UI ====================
    const ChatUI = {
      container: null,
      messages: [],
      mediaMap: new Map(),
      lastDate: null,
      observer: null,

      init() {
        this.container = document.getElementById('chatContainer');
        this.setupIntersectionObserver();
      },

      setupIntersectionObserver() {
        this.observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              const img = entry.target;
              if (img.dataset.src) {
                img.src = img.dataset.src;
                img.removeAttribute('data-src');
                this.observer.unobserve(img);
              }
            }
          });
        }, {
          rootMargin: '50px'
        });
      },

      async renderMessages(messages, mediaFiles) {
        this.messages = messages;
        this.mediaMap.clear();

        // Medya dosyalarƒ±nƒ± map'e ekle (birden fazla key ile)
        for (let file of mediaFiles) {
          const name = file.name.toLowerCase();
          // Tam dosya adƒ± ile
          this.mediaMap.set(name, file);
          // Sadece dosya adƒ± (path olmadan)
          const fileNameOnly = name.split('/').pop();
          if (fileNameOnly !== name) {
            this.mediaMap.set(fileNameOnly, file);
          }
          // Dosya adƒ±nƒ±n ba≈üƒ±ndaki numarayƒ± da key olarak ekle
          const numberMatch = name.match(/^(\d+)/);
          if (numberMatch) {
            this.mediaMap.set(numberMatch[1], file);
          }
        }

        console.log('Medya map\'e eklenen dosyalar:', this.mediaMap.size, 'adet');
        console.log('Medya dosyalarƒ± √∂rnekleri:', Array.from(this.mediaMap.keys()).slice(0, 20));

        this.container.innerHTML = '';
        this.lastDate = null;

        // Virtual scrolling i√ßin sadece g√∂r√ºnen mesajlarƒ± render et
        await this.renderVisibleMessages();
        this.setupVirtualScrolling();
      },

      async renderVisibleMessages() {
        const fragment = document.createDocumentFragment();
        const viewportHeight = window.innerHeight;
        const itemHeight = 60; // Ortalama mesaj y√ºksekliƒüi
        const buffer = 5; // Buffer mesaj sayƒ±sƒ±
        
        // ƒ∞lk y√ºklemede t√ºm mesajlarƒ± render et (daha sonra virtual scrolling devreye girer)
        for (let i = 0; i < this.messages.length; i++) {
          const message = this.messages[i];
          const previousMessage = i > 0 ? this.messages[i - 1] : null;
          const messageEl = await this.createMessageElement(message, previousMessage);
          fragment.appendChild(messageEl);
        }

        this.container.appendChild(fragment);
      },

      setupVirtualScrolling() {
        // Scroll event i√ßin debounce
        let scrollTimeout;
        this.container.addEventListener('scroll', () => {
          clearTimeout(scrollTimeout);
          scrollTimeout = setTimeout(() => {
            // Scroll pozisyonunu kaydet
            localStorage.setItem('chatScrollPosition', this.container.scrollTop);
          }, 300);
        });

        // √ñnceki scroll pozisyonunu geri y√ºkle
        const savedPosition = localStorage.getItem('chatScrollPosition');
        if (savedPosition) {
          setTimeout(() => {
            this.container.scrollTop = parseInt(savedPosition);
          }, 100);
        }
      },

      async createMessageElement(message, previousMessage = null) {
        const group = document.createElement('div');
        group.className = 'message-group';

        // Tarih ayƒ±rƒ±cƒ±
        const messageDate = new Date(message.date);
        const dateStr = messageDate.toDateString();
        
        if (!this.lastDate || this.lastDate !== dateStr) {
          const separator = document.createElement('div');
          separator.className = 'date-separator';
          separator.innerHTML = `<span>${Utils.formatDate(messageDate)}</span>`;
          group.appendChild(separator);
          this.lastDate = dateStr;
        }

        // Mesaj elementi
        const isSent = message.sender === 'Sen' || message.sender === 'You' || message.sender === 'Salih G√ºng√∂r';
        const messageEl = document.createElement('div');
        messageEl.className = `message ${isSent ? 'sent' : 'received'}`;

        // Aynƒ± ki≈üiden ardƒ±≈üƒ±k mesajlar i√ßin margin ayarla
        if (previousMessage) {
          const prevIsSent = previousMessage.sender === 'Sen' || previousMessage.sender === 'You' || previousMessage.sender === 'Salih G√ºng√∂r';
          if (isSent === prevIsSent && previousMessage.sender === message.sender) {
            messageEl.style.marginTop = '1px';
          }
        }

        const content = document.createElement('div');
        content.className = 'message-content';

        // Header (sadece received mesajlar i√ßin ve √∂nceki mesaj farklƒ± ki≈üiden ise)
        if (messageEl.classList.contains('received')) {
          const showHeader = !previousMessage || 
                            previousMessage.sender !== message.sender ||
                            (previousMessage.sender === message.sender && 
                             new Date(message.date).getTime() - new Date(previousMessage.date).getTime() > 300000); // 5 dakika
          
          if (showHeader) {
            const header = document.createElement('div');
            header.className = 'message-header';
            
            const avatar = document.createElement('div');
            avatar.className = 'avatar';
            avatar.style.background = Utils.getAvatarColor(message.sender);
            avatar.textContent = Utils.getInitials(message.sender);
            
            const name = document.createElement('span');
            name.className = 'sender-name';
            name.textContent = message.sender;

            header.appendChild(avatar);
            header.appendChild(name);
            content.appendChild(header);
          } else {
            // Avatar bo≈üluƒüu ekle
            const avatarSpacer = document.createElement('div');
            avatarSpacer.className = 'avatar';
            avatarSpacer.style.visibility = 'hidden';
            avatarSpacer.style.width = '0';
            avatarSpacer.style.margin = '0';
            const header = document.createElement('div');
            header.className = 'message-header';
            header.appendChild(avatarSpacer);
            content.appendChild(header);
          }
        }

        // Bubble
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble';

        if (message.isMedia && message.media) {
          // Medya dosyasƒ± varsa g√∂r√ºnt√ºle (async)
          await this.createMediaElement(bubble, message);
        } else {
          const text = document.createElement('div');
          text.className = 'message-text';
          text.textContent = message.text;
          bubble.appendChild(text);
        }

        // Time
        const time = document.createElement('div');
        time.className = 'message-time';
        time.textContent = Utils.formatTime(messageDate);
        bubble.appendChild(time);

        content.appendChild(bubble);
        messageEl.appendChild(content);
        group.appendChild(messageEl);

        return group;
      },

      async createMediaElement(bubble, message) {
        // Medya dosyasƒ±nƒ± bul (case-insensitive ve farklƒ± formatlarda)
        let mediaFile = null;
        let mediaName = message.media.toLowerCase().trim();
        
        // Dosya adƒ±nƒ± temizle (√∂zel karakterleri kaldƒ±r)
        mediaName = mediaName.replace(/[<>]/g, '').trim();
        
        // Path'ten sadece dosya adƒ±nƒ± al
        const mediaNameOnly = mediaName.split('/').pop();
        
        console.log('Aranan medya:', mediaName, '| Sadece ad:', mediaNameOnly);
        console.log('Mevcut medya dosyalarƒ±:', Array.from(this.mediaMap.keys()).slice(0, 20));
        
        // √ñnce tam e≈üle≈üme dene (tam dosya adƒ±)
        mediaFile = this.mediaMap.get(mediaName);
        
        // Sadece dosya adƒ± ile dene
        if (!mediaFile) {
          mediaFile = this.mediaMap.get(mediaNameOnly);
        }
        
        // Eƒüer bulunamazsa, farklƒ± e≈üle≈ütirme y√∂ntemleri dene
        if (!mediaFile) {
          // T√ºm medya dosyalarƒ±nƒ± kontrol et
          for (let [fileName, file] of this.mediaMap.entries()) {
            const fileNameLower = fileName.toLowerCase();
            
            // 1. Tam e≈üle≈üme (case-insensitive)
            if (fileNameLower === mediaName) {
              mediaFile = file;
              console.log('Tam e≈üle≈üme bulundu:', fileName);
              break;
            }
            
            // 2. Dosya adƒ± i√ßinde ge√ßiyorsa (kƒ±smi e≈üle≈üme)
            if (fileNameLower.includes(mediaName) || mediaName.includes(fileNameLower)) {
              mediaFile = file;
              console.log('Kƒ±smi e≈üle≈üme bulundu:', fileName);
              break;
            }
            
            // 3. Dosya adƒ±nƒ±n ba≈üƒ±ndaki numarayƒ± kontrol et (√∂rn: 00000053)
            const mediaPrefix = mediaName.match(/^(\d+)/);
            if (mediaPrefix) {
              const prefix = mediaPrefix[1];
              if (fileNameLower.startsWith(prefix) || fileNameLower.includes(prefix)) {
                mediaFile = file;
                console.log('Prefix e≈üle≈ümesi bulundu:', fileName);
                break;
              }
            }
            
            // 4. Dosya adƒ±nƒ±n sonundaki uzantƒ±yƒ± kontrol et
            const mediaExt = mediaName.split('.').pop();
            const fileExt = fileNameLower.split('.').pop();
            if (mediaExt && fileExt && mediaExt === fileExt) {
              // Uzantƒ± e≈üle≈üiyorsa, dosya adƒ±nƒ±n b√ºy√ºk kƒ±smƒ±nƒ± kontrol et
              const mediaBase = mediaName.replace('.' + mediaExt, '');
              const fileBase = fileNameLower.replace('.' + fileExt, '');
              if (fileBase.includes(mediaBase) || mediaBase.includes(fileBase)) {
                mediaFile = file;
                console.log('Uzantƒ± + base e≈üle≈ümesi bulundu:', fileName);
                break;
              }
            }
            
            // 5. Dosya adƒ±nƒ±n ortasƒ±ndaki tarih/numara kƒ±smƒ±nƒ± kontrol et
            const mediaNumbers = mediaName.match(/\d+/g);
            if (mediaNumbers && mediaNumbers.length > 0) {
              const hasCommonNumbers = mediaNumbers.some(num => fileNameLower.includes(num));
              if (hasCommonNumbers && fileNameLower.length > 10) {
                // Eƒüer ortak numaralar varsa ve dosya adƒ± yeterince uzunsa
                mediaFile = file;
                console.log('Numara e≈üle≈ümesi bulundu:', fileName);
                break;
              }
            }
          }
        }
        
        if (mediaFile) {
          console.log('Medya dosyasƒ± bulundu:', mediaFile.name);
        } else {
          console.log('Medya dosyasƒ± bulunamadƒ±:', mediaName);
        }

        if (!mediaFile) {
          // Medya dosyasƒ± bulunamadƒ±ysa bile dosya adƒ±nƒ± ve indirme linkini g√∂ster
          const container = document.createElement('div');
          container.className = 'media-container';
          
          const link = document.createElement('div');
          link.className = 'document-link';
          link.style.cursor = 'default';
          
          const icon = this.getFileIcon(message.media, '');
          const ext = message.media.split('.').pop().toLowerCase();
          const fileSize = 'Dosya bulunamadƒ±';
          
          link.innerHTML = `
            <div class="document-icon" style="font-size: 48px;">${icon}</div>
            <div class="document-info">
              <div class="document-name">${message.media}</div>
              <div class="document-size" style="color: var(--text-secondary);">${fileSize}</div>
            </div>
          `;
          
          container.appendChild(link);
          bubble.appendChild(container);
          return;
        }

        const container = document.createElement('div');
        container.className = 'media-container';

        // Blob URL olu≈ütur
        let blob = await Storage.getMedia(mediaFile.name);
        if (!blob) {
          // Eƒüer IndexedDB'de yoksa, dosyayƒ± kaydet
          await Storage.saveMedia(mediaFile.name, mediaFile, mediaFile.type);
          blob = await Storage.getMedia(mediaFile.name);
        }
        
        const url = URL.createObjectURL(blob);
        await this.createMediaElementByType(container, url, mediaFile, blob);

        // Video ve audio i√ßin click event ekleme (kendi kontrolleri var)
        if (!mediaFile.type.startsWith('video/') && !mediaFile.type.startsWith('audio/')) {
          container.addEventListener('click', () => {
            MediaViewer.showMedia(mediaFile.name, mediaFile.type);
          });
        }

        bubble.appendChild(container);
      },

      async createMediaElementByType(container, url, file, blob) {
        if (file.type.startsWith('image/')) {
          const img = document.createElement('img');
          
          // √ñnce placeholder g√∂ster
          img.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="200" height="200"%3E%3Crect width="200" height="200" fill="%23f0f0f0"/%3E%3C/svg%3E';
          img.className = 'media-thumbnail';
          img.loading = 'lazy';
          container.appendChild(img);
          
          // Thumbnail olu≈ütur ve kullan (async, non-blocking)
          ThumbnailGenerator.generateThumbnail(blob, 200, 200)
            .then(thumbnail => {
              const thumbnailUrl = URL.createObjectURL(thumbnail);
              img.src = thumbnailUrl;
              img.dataset.fullSrc = url;
            })
            .catch(() => {
              // Thumbnail olu≈üturulamazsa normal resmi g√∂ster
              img.src = url;
            });
          
          // Lazy loading i√ßin observer'a ekle
          if (this.observer) {
            this.observer.observe(img);
          }
        } else if (file.type.startsWith('video/')) {
          const video = document.createElement('video');
          video.src = url;
          video.className = 'media-thumbnail';
          video.controls = true;
          video.preload = 'metadata';
          container.appendChild(video);
        } else if (file.type.startsWith('audio/')) {
          const audioContainer = document.createElement('div');
          audioContainer.className = 'audio-player-container';
          const audio = document.createElement('audio');
          audio.src = url;
          audio.controls = true;
          audio.className = 'audio-player';
          audioContainer.appendChild(audio);
          container.appendChild(audioContainer);
        } else if (file.type === 'application/pdf') {
          // PDF i√ßin √∂zel g√∂r√ºnt√ºleme
          const pdfContainer = document.createElement('div');
          pdfContainer.className = 'document-link';
          pdfContainer.style.cursor = 'pointer';
          pdfContainer.innerHTML = `
            <div class="document-icon" style="font-size: 48px;">üìï</div>
            <div class="document-info">
              <div class="document-name">${file.name}</div>
              <div class="document-size">${this.formatFileSize(file.size)}</div>
              <div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">PDF - Tƒ±klayarak g√∂r√ºnt√ºle</div>
            </div>
          `;
          pdfContainer.addEventListener('click', () => {
            // PDF'i yeni sekmede a√ß
            window.open(url, '_blank');
          });
          container.appendChild(pdfContainer);
        } else if (file.type.includes('document') || 
                   file.type.includes('spreadsheet') || 
                   file.type.includes('presentation') ||
                   file.name.match(/\.(doc|docx|xls|xlsx|ppt|pptx|rtf|odt|ods|odp)$/i)) {
          // Office dok√ºmanlarƒ±
          const docContainer = document.createElement('div');
          docContainer.className = 'document-link';
          docContainer.style.cursor = 'pointer';
          const icon = this.getDocumentIcon(file.name);
          docContainer.innerHTML = `
            <div class="document-icon" style="font-size: 48px;">${icon}</div>
            <div class="document-info">
              <div class="document-name">${file.name}</div>
              <div class="document-size">${this.formatFileSize(file.size)}</div>
              <div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">Dok√ºman - ƒ∞ndir</div>
            </div>
          `;
          docContainer.addEventListener('click', () => {
            const link = document.createElement('a');
            link.href = url;
            link.download = file.name;
            link.click();
          });
          container.appendChild(docContainer);
        } else if (file.type.includes('archive') || 
                   file.type.includes('zip') || 
                   file.type.includes('rar') ||
                   file.name.match(/\.(zip|rar|7z|tar|gz)$/i)) {
          // Ar≈üiv dosyalarƒ±
          const archiveContainer = document.createElement('div');
          archiveContainer.className = 'document-link';
          archiveContainer.innerHTML = `
            <div class="document-icon" style="font-size: 48px;">üì¶</div>
            <div class="document-info">
              <div class="document-name">${file.name}</div>
              <div class="document-size">${this.formatFileSize(file.size)}</div>
            </div>
          `;
          container.appendChild(archiveContainer);
        } else {
          // Diƒüer t√ºm dosya t√ºrleri i√ßin genel g√∂r√ºnt√ºleyici
          const link = document.createElement('a');
          link.href = url;
          link.download = file.name;
          link.className = 'document-link';
          const icon = this.getFileIcon(file.name, file.type);
          link.innerHTML = `
            <div class="document-icon" style="font-size: 48px;">${icon}</div>
            <div class="document-info">
              <div class="document-name">${file.name}</div>
              <div class="document-size">${this.formatFileSize(file.size)}</div>
              <div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">${file.type || 'Dosya'}</div>
            </div>
          `;
          container.appendChild(link);
        }
      },

      getDocumentIcon(fileName) {
        const ext = fileName.split('.').pop().toLowerCase();
        const icons = {
          'doc': 'üìù',
          'docx': 'üìù',
          'xls': 'üìä',
          'xlsx': 'üìä',
          'ppt': 'üìΩÔ∏è',
          'pptx': 'üìΩÔ∏è',
          'rtf': 'üìÑ',
          'odt': 'üìù',
          'ods': 'üìä',
          'odp': 'üìΩÔ∏è'
        };
        return icons[ext] || 'üìÑ';
      },

      getFileIcon(fileName, mimeType) {
        const ext = fileName.split('.').pop().toLowerCase();
        const icons = {
          'pdf': 'üìï',
          'zip': 'üì¶',
          'rar': 'üì¶',
          '7z': 'üì¶',
          'exe': '‚öôÔ∏è',
          'apk': 'üì±',
          'dmg': 'üíø',
          'html': 'üåê',
          'htm': 'üåê',
          'css': 'üé®',
          'js': 'üíª',
          'json': 'üìã',
          'xml': 'üìã',
          'txt': 'üìÑ',
          'log': 'üìã'
        };
        return icons[ext] || 'üìé';
      },

      formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
      }
    };

    // ==================== MAIN APP ====================
    const App = {
      txtFile: null,
      mediaFiles: [],

      async init() {
        await Storage.init();
        ChatUI.init();
        MediaViewer.init();
        this.setupEventListeners();
      },

      setupEventListeners() {
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const txtInput = document.getElementById('txtFileInput');
        const mediaInput = document.getElementById('mediaFileInput');

        // Drag and drop
        uploadArea.addEventListener('dragover', (e) => {
          e.preventDefault();
          uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
          uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
          e.preventDefault();
          uploadArea.classList.remove('dragover');
          
          // Klas√∂r m√º kontrol et
          const items = Array.from(e.dataTransfer.items);
          const hasDirectory = items.some(item => item.webkitGetAsEntry && item.webkitGetAsEntry().isDirectory);
          
          if (hasDirectory) {
            // Klas√∂r y√ºkleme
            folderInput.files = e.dataTransfer.files;
            folderInput.dispatchEvent(new Event('change'));
          } else {
            // Dosya y√ºkleme
            this.handleFiles(e.dataTransfer.files);
          }
        });

        uploadArea.addEventListener('click', () => {
          fileInput.click();
        });

        fileInput.addEventListener('change', async (e) => {
          if (e.target.files.length > 0) {
            const file = e.target.files[0];
            if (file.name.endsWith('.zip')) {
              await this.handleZipFile(file);
            } else if (this.isTextFile(file.name)) {
              await this.handleChatFile(file);
              // Eski y√∂ntem: medya klas√∂r√º se√ßimi
              mediaInput.click();
            }
          }
        });

        // Eski y√∂ntem i√ßin (geriye d√∂n√ºk uyumluluk)
        txtInput.addEventListener('change', (e) => {
          if (e.target.files.length > 0) {
            this.handleTxtFile(e.target.files[0]);
            mediaInput.click();
          }
        });

        mediaInput.addEventListener('change', (e) => {
          this.handleMediaFiles(Array.from(e.target.files));
        });

        // Klas√∂r y√ºkleme
        folderInput.addEventListener('change', async (e) => {
          if (e.target.files.length > 0) {
            await this.handleFolderFiles(Array.from(e.target.files));
          }
        });
      },

      async handleFolderFiles(files) {
        const loading = document.getElementById('loading');
        loading.style.display = 'block';
        loading.textContent = 'Klas√∂r i≈üleniyor...';

        try {
          let chatFile = null;
          const mediaFiles = [];

          // Dosyalarƒ± ayƒ±r
          for (let file of files) {
            if (this.isTextFile(file.name)) {
              // Chat dosyasƒ± mƒ± kontrol et
              if (!chatFile || 
                  file.name.toLowerCase().includes('chat') || 
                  file.name.toLowerCase().startsWith('_chat') ||
                  file.name.toLowerCase() === 'chat.txt' ||
                  file.name.toLowerCase() === '_chat.txt') {
                chatFile = file;
              }
            } else {
              mediaFiles.push(file);
            }
          }

          if (!chatFile) {
            this.showError('Klas√∂rde sohbet dosyasƒ± bulunamadƒ±. (_chat.txt, chat.txt gibi dosyalar aranƒ±yor)');
            loading.style.display = 'none';
            return;
          }

          // Medya dosyalarƒ±nƒ± kaydet
          for (let file of mediaFiles) {
            await Storage.saveMedia(file.name, file, file.type);
          }

          // Mesajlarƒ± parse et ve g√∂ster
          const text = await chatFile.text();
          const result = WhatsAppParser.parse(text);
          const messages = result.messages;
          
          if (messages.length === 0) {
            let errorMsg = 'Mesaj bulunamadƒ±. Dosya formatƒ±nƒ± kontrol edin.\n\n';
            if (result.sampleLines && result.sampleLines.length > 0) {
              errorMsg += 'Dosyanƒ±n ilk satƒ±rlarƒ±:\n';
              result.sampleLines.slice(0, 3).forEach((line, i) => {
                errorMsg += `${i + 1}. ${line.substring(0, 100)}${line.length > 100 ? '...' : ''}\n`;
              });
            }
            this.showError(errorMsg);
            loading.style.display = 'none';
            console.error('Parser Debug:', result);
            return;
          }

          // Medya dosyalarƒ±nƒ± kaydet ve renderMessages'a ge√ßir
          this.mediaFiles = mediaFiles;
          console.log('Klas√∂rden medya dosyalarƒ±:', mediaFiles.length, 'adet');
          console.log('Medya dosya isimleri:', mediaFiles.map(f => f.name).slice(0, 10));
          await this.processFiles(messages);

        } catch (error) {
          console.error('Klas√∂r i≈üleme hatasƒ±:', error);
          this.showError('Klas√∂r i≈ülenirken hata olu≈ütu: ' + error.message);
          loading.style.display = 'none';
        }
      },

      isTextFile(fileName) {
        const textExtensions = ['.txt', '.text', '.json', '.csv', '.xml', '.log'];
        const lowerName = fileName.toLowerCase();
        // Ayrƒ±ca dosya adƒ±nda "chat" ge√ßiyorsa da text dosyasƒ± olabilir
        return textExtensions.some(ext => lowerName.endsWith(ext)) || 
               lowerName.includes('chat') || 
               lowerName.startsWith('_chat') ||
               lowerName === 'chat.txt' ||
               lowerName === '_chat.txt';
      },

      async handleChatFile(file) {
        this.txtFile = file;
        const text = await file.text();
        const result = WhatsAppParser.parse(text);
        const messages = result.messages;
        
        if (messages.length === 0) {
          let errorMsg = 'Mesaj bulunamadƒ±. Dosya formatƒ±nƒ± kontrol edin.\n\n';
          if (result.sampleLines && result.sampleLines.length > 0) {
            errorMsg += 'Dosyanƒ±n ilk satƒ±rlarƒ±:\n';
            result.sampleLines.slice(0, 3).forEach((line, i) => {
              errorMsg += `${i + 1}. ${line.substring(0, 100)}${line.length > 100 ? '...' : ''}\n`;
            });
            errorMsg += '\nL√ºtfen dosyanƒ±n WhatsApp export formatƒ±nda olduƒüundan emin olun.';
          }
          this.showError(errorMsg);
          console.error('Parser Debug:', result);
          return;
        }

        // Medya dosyalarƒ± y√ºklenene kadar bekle
        if (this.mediaFiles.length > 0) {
          await this.processFiles(messages);
        }
      },

      async handleMediaFiles(files) {
        this.mediaFiles = files;
        
        // Medya dosyalarƒ±nƒ± IndexedDB'ye kaydet
        for (let file of files) {
          await Storage.saveMedia(file.name, file, file.type);
        }

        if (this.txtFile) {
          const text = await this.txtFile.text();
          const result = WhatsAppParser.parse(text);
          const messages = result.messages;
          if (messages.length > 0) {
            await this.processFiles(messages);
          } else {
            this.showError('Mesaj bulunamadƒ±. Dosya formatƒ±nƒ± kontrol edin.');
          }
        }
      },

      async handleZipFile(zipFile) {
        const loading = document.getElementById('loading');
        loading.style.display = 'block';
        loading.textContent = 'Zip dosyasƒ± a√ßƒ±lƒ±yor...';

        try {
          // JSZip kontrol√º
          if (typeof JSZip === 'undefined') {
            this.showError('JSZip k√ºt√ºphanesi y√ºklenemedi. L√ºtfen sayfayƒ± yenileyin.');
            loading.style.display = 'none';
            return;
          }

          const zip = await JSZip.loadAsync(zipFile);
          const files = zip.files;
          
          let chatFile = null;
          const mediaFiles = [];

          // Zip i√ßindeki dosyalarƒ± i≈üle
          for (const [path, zipEntry] of Object.entries(files)) {
            if (zipEntry.dir) continue; // Klas√∂rleri atla

            const fileName = path.split('/').pop(); // Dosya adƒ±nƒ± al
            const blob = await zipEntry.async('blob');
            
            // File objesi olu≈ütur
            const file = new File([blob], fileName, { type: this.getMimeType(fileName) });

            // Text dosyasƒ± mƒ± kontrol et (chat dosyasƒ± olabilir)
            if (this.isTextFile(fileName)) {
              // Eƒüer hen√ºz chat dosyasƒ± bulunamadƒ±ysa veya bu dosya daha uygun bir chat dosyasƒ±ysa
              if (!chatFile || 
                  fileName.toLowerCase().includes('chat') || 
                  fileName.toLowerCase().startsWith('_chat') ||
                  fileName.toLowerCase() === 'chat.txt' ||
                  fileName.toLowerCase() === '_chat.txt') {
                chatFile = file;
              }
            } else {
              mediaFiles.push(file);
            }
          }

          if (!chatFile) {
            this.showError('Zip dosyasƒ±nda sohbet dosyasƒ± bulunamadƒ±. (.txt, .text, _chat.txt gibi dosyalar aranƒ±yor)');
            loading.style.display = 'none';
            return;
          }

          // Medya dosyalarƒ±nƒ± kaydet
          for (let file of mediaFiles) {
            await Storage.saveMedia(file.name, file, file.type);
          }

          // Mesajlarƒ± parse et ve g√∂ster
          const text = await chatFile.text();
          const result = WhatsAppParser.parse(text);
          const messages = result.messages;
          
          if (messages.length === 0) {
            let errorMsg = 'Mesaj bulunamadƒ±. Dosya formatƒ±nƒ± kontrol edin.\n\n';
            if (result.sampleLines && result.sampleLines.length > 0) {
              errorMsg += 'Dosyanƒ±n ilk satƒ±rlarƒ±:\n';
              result.sampleLines.slice(0, 3).forEach((line, i) => {
                errorMsg += `${i + 1}. ${line.substring(0, 100)}${line.length > 100 ? '...' : ''}\n`;
              });
            }
            this.showError(errorMsg);
            loading.style.display = 'none';
            console.error('Parser Debug:', result);
            return;
          }

          // Medya dosyalarƒ±nƒ± kaydet ve renderMessages'a ge√ßir
          this.mediaFiles = mediaFiles;
          console.log('Medya dosyalarƒ±:', mediaFiles.length, 'adet');
          console.log('Medya dosya isimleri:', mediaFiles.map(f => f.name).slice(0, 10));
          await this.processFiles(messages);

        } catch (error) {
          console.error('Zip a√ßma hatasƒ±:', error);
          this.showError('Zip dosyasƒ± a√ßƒ±lamadƒ±: ' + error.message);
          loading.style.display = 'none';
        }
      },

      getMimeType(fileName) {
        const ext = fileName.split('.').pop().toLowerCase();
        const mimeTypes = {
          // Images
          'jpg': 'image/jpeg',
          'jpeg': 'image/jpeg',
          'png': 'image/png',
          'gif': 'image/gif',
          'webp': 'image/webp',
          'bmp': 'image/bmp',
          'svg': 'image/svg+xml',
          'ico': 'image/x-icon',
          'tiff': 'image/tiff',
          'tif': 'image/tiff',
          // Videos
          'mp4': 'video/mp4',
          'webm': 'video/webm',
          'ogg': 'video/ogg',
          'ogv': 'video/ogg',
          'avi': 'video/x-msvideo',
          'mov': 'video/quicktime',
          'wmv': 'video/x-ms-wmv',
          'flv': 'video/x-flv',
          'mkv': 'video/x-matroska',
          '3gp': 'video/3gpp',
          'm4v': 'video/mp4',
          // Audio
          'mp3': 'audio/mpeg',
          'wav': 'audio/wav',
          'opus': 'audio/opus',
          'ogg': 'audio/ogg',
          'oga': 'audio/ogg',
          'm4a': 'audio/mp4',
          'aac': 'audio/aac',
          'flac': 'audio/flac',
          'wma': 'audio/x-ms-wma',
          'amr': 'audio/amr',
          // Documents
          'pdf': 'application/pdf',
          'doc': 'application/msword',
          'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
          'xls': 'application/vnd.ms-excel',
          'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
          'ppt': 'application/vnd.ms-powerpoint',
          'pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
          'rtf': 'application/rtf',
          'odt': 'application/vnd.oasis.opendocument.text',
          'ods': 'application/vnd.oasis.opendocument.spreadsheet',
          'odp': 'application/vnd.oasis.opendocument.presentation',
          // Archives
          'zip': 'application/zip',
          'rar': 'application/x-rar-compressed',
          '7z': 'application/x-7z-compressed',
          'tar': 'application/x-tar',
          'gz': 'application/gzip',
          // Text
          'txt': 'text/plain',
          'html': 'text/html',
          'htm': 'text/html',
          'css': 'text/css',
          'js': 'text/javascript',
          'json': 'application/json',
          'xml': 'application/xml',
          'csv': 'text/csv',
          // Other
          'apk': 'application/vnd.android.package-archive',
          'exe': 'application/x-msdownload',
          'dmg': 'application/x-apple-diskimage'
        };
        return mimeTypes[ext] || 'application/octet-stream';
      },

      async handleFiles(files) {
        // Zip dosyasƒ± kontrol√º
        const zipFile = Array.from(files).find(f => f.name.endsWith('.zip'));
        if (zipFile) {
          await this.handleZipFile(zipFile);
          return;
        }

        // Eski y√∂ntem: chat dosyasƒ± + medya dosyalarƒ±
        const chatFile = Array.from(files).find(f => this.isTextFile(f.name));
        const mediaFiles = Array.from(files).filter(f => !this.isTextFile(f.name));

        if (chatFile) {
          await this.handleChatFile(chatFile);
        }

        if (mediaFiles.length > 0) {
          await this.handleMediaFiles(mediaFiles);
        }
      },

      async processFiles(messages) {
        const loading = document.getElementById('loading');
        loading.style.display = 'block';

        try {
          await ChatUI.renderMessages(messages, this.mediaFiles);
          
          document.getElementById('uploadSection').classList.add('hidden');
          loading.style.display = 'none';
          
          // Stats
          const stats = document.getElementById('stats');
          const messageCount = document.getElementById('messageCount');
          const mediaCount = document.getElementById('mediaCount');
          
          messageCount.textContent = messages.length;
          mediaCount.textContent = this.mediaFiles.length;
          stats.classList.remove('hidden');
        } catch (error) {
          this.showError('Hata: ' + error.message);
          loading.style.display = 'none';
        }
      },

      showError(message) {
        const errorEl = document.getElementById('error');
        errorEl.textContent = message;
        errorEl.classList.remove('hidden');
        setTimeout(() => {
          errorEl.classList.add('hidden');
        }, 5000);
      }
    };

    // ==================== THUMBNAIL GENERATION ====================
    const ThumbnailGenerator = {
      async generateThumbnail(blob, maxWidth = 200, maxHeight = 200) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          const url = URL.createObjectURL(blob);
          
          img.onload = () => {
            URL.revokeObjectURL(url);
            
            const canvas = document.createElement('canvas');
            let width = img.width;
            let height = img.height;
            
            // Calculate dimensions
            if (width > height) {
              if (width > maxWidth) {
                height = (height * maxWidth) / width;
                width = maxWidth;
              }
            } else {
              if (height > maxHeight) {
                width = (width * maxHeight) / height;
                height = maxHeight;
              }
            }
            
            canvas.width = width;
            canvas.height = height;
            
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            
            canvas.toBlob((thumbnailBlob) => {
              resolve(thumbnailBlob);
            }, 'image/jpeg', 0.8);
          };
          
          img.onerror = () => {
            URL.revokeObjectURL(url);
            reject(new Error('Thumbnail generation failed'));
          };
          
          img.src = url;
        });
      }
    };

    // ==================== SERVICE WORKER ====================
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        const swCode = `
          const CACHE_NAME = 'whatsapp-viewer-v1';
          const urlsToCache = [
            '/',
            '/index.html',
            '/manifest.json'
          ];

          self.addEventListener('install', (event) => {
            event.waitUntil(
              caches.open(CACHE_NAME)
                .then((cache) => cache.addAll(urlsToCache))
            );
          });

          self.addEventListener('fetch', (event) => {
            event.respondWith(
              caches.match(event.request)
                .then((response) => {
                  return response || fetch(event.request);
                })
            );
          });
        `;

        const blob = new Blob([swCode], { type: 'application/javascript' });
        const swUrl = URL.createObjectURL(blob);
        
        navigator.serviceWorker.register(swUrl)
          .then(() => {
            URL.revokeObjectURL(swUrl);
          })
          .catch(() => {
            // Service worker registration failed, continue without it
          });
      });
    }

    // ==================== INITIALIZE APP ====================
    document.addEventListener('DOMContentLoaded', () => {
      App.init();
    });
  </script>
</body>
</html>

