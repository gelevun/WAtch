<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
  <meta name="description" content="WhatsApp sohbet g√∂r√ºnt√ºleyici - ZIP veya klas√∂r y√ºkleyerek sohbetleri g√∂r√ºnt√ºleyin">
  <meta name="theme-color" content="#075e54">
  <title>WhatsApp Chat Viewer</title>
  <link rel="manifest" href="manifest.json">
  
  <!-- CDN Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: #0b141a;
      color: #e9edef;
      height: 100vh;
      overflow: hidden;
      margin: 0;
      padding: 0;
    }
    
    #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100vw;
      margin: 0;
      padding: 0;
    }
    
    /* Header */
    .header {
      background: #202c33;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      border-bottom: 1px solid #313d45;
    }
    
    .header h1 {
      font-size: 16px;
      font-weight: 500;
      flex: 1;
    }
    
    .header button {
      background: #2a3942;
      border: none;
      color: #e9edef;
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
    }
    
    .header button:hover {
      background: #344249;
    }
    
    /* Upload Area */
    #upload-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      padding: 20px;
      text-align: center;
    }
    
    #upload-area.hidden {
      display: none;
    }
    
    .upload-box {
      border: 2px dashed #313d45;
      border-radius: 12px;
      padding: 40px;
      max-width: 400px;
      width: 100%;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .upload-box:hover {
      border-color: #00a884;
      background: #202c33;
    }
    
    .upload-box.dragover {
      border-color: #00a884;
      background: #202c33;
    }
    
    .upload-icon {
      font-size: 48px;
      margin-bottom: 16px;
    }
    
    .upload-text {
      font-size: 16px;
      margin-bottom: 8px;
    }
    
    .upload-hint {
      font-size: 14px;
      color: #8696a0;
      margin-top: 8px;
    }
    
    .upload-buttons {
      margin-top: 20px;
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .btn-zip,
    .btn-folder {
      background: #00a884;
      border: none;
      color: white;
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      flex: 1;
      min-width: 120px;
      max-width: 200px;
    }
    
    .btn-folder {
      background: #2a3942;
      color: #e9edef;
    }
    
    .btn-zip:active,
    .btn-folder:active {
      opacity: 0.8;
    }
    
    input[type="file"] {
      display: none;
    }
    
    /* Chat Area */
    #chat-area {
      display: none;
      flex-direction: column;
      height: 100%;
      background: #0b141a;
    }
    
    #chat-area.visible {
      display: flex;
    }
    
    .chat-header {
      background: #202c33;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      border-bottom: 1px solid #313d45;
    }
    
    .chat-title {
      flex: 1;
      font-size: 16px;
      font-weight: 500;
    }
    
    .chat-info {
      font-size: 12px;
      color: #8696a0;
    }
    
    /* Messages Container */
    .messages-container {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 8px 4px;
      background-image: 
        linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
      background-size: 20px 20px;
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
      will-change: scroll-position;
      overscroll-behavior: contain;
    }
    
    .messages-container::-webkit-scrollbar {
      width: 6px;
    }
    
    .messages-container::-webkit-scrollbar-track {
      background: transparent;
    }
    
    .messages-container::-webkit-scrollbar-thumb {
      background: #313d45;
      border-radius: 3px;
    }
    
    /* Date Separator */
    .date-separator {
      text-align: center;
      margin: 16px 0;
      position: relative;
    }
    
    .date-separator::before,
    .date-separator::after {
      content: '';
      position: absolute;
      top: 50%;
      width: 30%;
      height: 1px;
      background: #313d45;
    }
    
    .date-separator::before {
      left: 0;
    }
    
    .date-separator::after {
      right: 0;
    }
    
    .date-text {
      display: inline-block;
      background: #202c33;
      padding: 4px 12px;
      border-radius: 8px;
      font-size: 12px;
      color: #8696a0;
      position: relative;
    }
    
    /* Message Bubble */
    .message-group {
      margin-bottom: 4px;
      display: flex;
      flex-direction: column;
    }
    
    .message-bubble {
      max-width: 65%;
      padding: 6px 8px;
      border-radius: 8px;
      margin-bottom: 2px;
      word-wrap: break-word;
      position: relative;
    }
    
    .message-bubble.sent {
      background: #005c4b;
      color: #ffffff;
      align-self: flex-end;
      border-bottom-right-radius: 4px;
    }
    
    .message-bubble.received {
      background: #202c33;
      color: #e9edef;
      align-self: flex-start;
      border-bottom-left-radius: 4px;
    }
    
    .message-time {
      font-size: 11px;
      margin-top: 4px;
      text-align: right;
    }
    
    .message-bubble.sent .message-time {
      color: rgba(255, 255, 255, 0.7);
    }
    
    .message-bubble.received .message-time {
      color: rgba(233, 237, 239, 0.6);
      text-align: left;
    }
    
    .message-sender {
      font-size: 13px;
      font-weight: 500;
      margin-bottom: 4px;
      color: #53bdeb;
    }
    
    .message-text {
      font-size: 14px;
      line-height: 1.4;
      color: inherit;
    }
    
    .message-bubble.sent .message-text {
      color: #ffffff;
    }
    
    .message-bubble.received .message-text {
      color: #e9edef;
    }
    
    /* Media Preview */
    .media-preview {
      margin-top: 8px;
      border-radius: 8px;
      overflow: hidden;
      cursor: pointer;
      position: relative;
    }
    
    .media-preview img {
      width: 100%;
      max-width: 300px;
      height: auto;
      display: block;
    }
    
    .media-preview.audio {
      background: #2a3942;
      padding: 12px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .media-preview.file {
      background: #2a3942;
      padding: 12px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .media-icon {
      font-size: 24px;
    }
    
    .media-info {
      flex: 1;
    }
    
    .media-name {
      font-size: 14px;
      font-weight: 500;
    }
    
    .media-size {
      font-size: 12px;
      color: #8696a0;
      margin-top: 2px;
    }
    
    /* Loading */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px;
      color: #8696a0;
    }
    
    .spinner {
      border: 3px solid #313d45;
      border-top: 3px solid #00a884;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin-right: 12px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Modal */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }
    
    .modal.active {
      display: flex;
    }
    
    .modal-content {
      max-width: 90%;
      max-height: 90%;
      position: relative;
    }
    
    .modal-close {
      position: absolute;
      top: -40px;
      right: 0;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 20px;
    }
    
    .modal-content img {
      max-width: 100%;
      max-height: 90vh;
    }
    
    .modal-content audio {
      width: 100%;
      min-width: 300px;
    }
    
    .modal-content iframe {
      width: 90vw;
      height: 90vh;
      border: none;
    }
    
    /* Responsive - Mobile */
    @media (max-width: 768px) {
      body {
        font-size: 14px;
      }
      
      .header {
        padding: 10px 12px;
      }
      
      .header h1 {
        font-size: 14px;
      }
      
      .header button {
        padding: 6px 12px;
        font-size: 12px;
      }
      
      .chat-header {
        padding: 10px 12px;
      }
      
      .chat-title {
        font-size: 14px;
      }
      
      .chat-info {
        font-size: 11px;
      }
      
      .chat-header button {
        padding: 6px 12px;
        font-size: 12px;
      }
      
      .messages-container {
        padding: 8px 2px;
      }
      
      .message-bubble {
        max-width: 90%;
        padding: 5px 7px;
      }
      
      .message-text {
        font-size: 13px;
      }
      
      .message-time {
        font-size: 10px;
      }
      
      .message-sender {
        font-size: 12px;
      }
      
      .date-separator {
        margin: 12px 0;
      }
      
      .date-text {
        font-size: 11px;
        padding: 3px 10px;
      }
      
      .upload-box {
        padding: 30px 20px;
        max-width: 100%;
      }
      
      .upload-icon {
        font-size: 40px;
      }
      
      .upload-text {
        font-size: 14px;
      }
      
      .upload-hint {
        font-size: 12px;
      }
      
      .media-preview img {
        max-width: 100%;
      }
      
      .modal-content {
        max-width: 95%;
        max-height: 95%;
      }
      
      .modal-content img {
        max-width: 100%;
        max-height: 95vh;
      }
      
      .modal-close {
        top: -35px;
        width: 28px;
        height: 28px;
        font-size: 18px;
      }
      
      .upload-buttons {
        flex-direction: column;
        gap: 10px;
      }
      
      .btn-zip,
      .btn-folder {
        width: 100%;
        max-width: 100%;
      }
    }
    
    /* Extra small devices */
    @media (max-width: 480px) {
      .message-bubble {
        max-width: 95%;
        padding: 4px 6px;
      }
      
      .messages-container {
        padding: 6px 2px;
      }
      
      .header button,
      .chat-header button {
        padding: 5px 10px;
        font-size: 11px;
      }
      
      .upload-box {
        padding: 20px 15px;
      }
      
      .date-separator::before,
      .date-separator::after {
        width: 25%;
      }
    }
    
    /* Prevent horizontal scroll */
    html, body {
      overflow-x: hidden;
      width: 100%;
      position: relative;
    }
    
    img, video {
      max-width: 100%;
      height: auto;
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- Upload Area -->
    <div id="upload-area">
      <div class="upload-box" id="upload-box">
        <div class="upload-icon">üìÅ</div>
        <div class="upload-text">WhatsApp Sohbet Dosyasƒ± Y√ºkle</div>
        <div class="upload-hint">
          ZIP dosyasƒ± veya klas√∂r se√ßin<br>
          <small>(S√ºr√ºkle-bƒ±rak desteklenir)</small>
        </div>
        <input type="file" id="file-input" webkitdirectory multiple>
        <input type="file" id="zip-input" accept=".zip">
      </div>
      <div class="upload-buttons">
        <button onclick="document.getElementById('zip-input').click()" class="btn-zip">ZIP Y√ºkle</button>
        <button onclick="document.getElementById('file-input').click()" class="btn-folder">Klas√∂r Se√ß</button>
      </div>
    </div>
    
    <!-- Chat Area -->
    <div id="chat-area">
      <div class="chat-header">
        <div class="chat-title" id="chat-title">Sohbet</div>
        <div class="chat-info" id="chat-info"></div>
        <button onclick="resetApp()">Yeni Y√ºkle</button>
      </div>
      <div class="messages-container" id="messages-container">
        <div class="loading">
          <div class="spinner"></div>
          <span>Y√ºkleniyor...</span>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Media Modal -->
  <div class="modal" id="media-modal">
    <button class="modal-close" onclick="closeMediaModal()">√ó</button>
    <div class="modal-content" id="modal-content"></div>
  </div>
  
  <script>
    // Global state
    let messages = [];
    let mediaFiles = new Map();
    let db = null;
    let currentDate = null;
    let firstSender = null; // ƒ∞lk mesajƒ± g√∂nderen ki≈üi (kullanƒ±cƒ±)
    
    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      initIndexedDB();
      setupFileUpload();
      registerServiceWorker();
    });
    
    // Register service worker
    function registerServiceWorker() {
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('service-worker.js')
          .then((registration) => {
            console.log('Service Worker registered:', registration);
          })
          .catch((error) => {
            console.log('Service Worker registration failed:', error);
          });
      }
    }
    
    // IndexedDB initialization
    function initIndexedDB() {
      const request = indexedDB.open('WhatsAppChatViewer', 2);
      
      request.onerror = () => {
        console.error('IndexedDB error:', request.error);
      };
      
      request.onsuccess = () => {
        db = request.result;
      };
      
      request.onupgradeneeded = (event) => {
        db = event.target.result;
        
        // Delete old object store if exists (to fix keyPath issue)
        if (db.objectStoreNames.contains('media')) {
          db.deleteObjectStore('media');
        }
        
        // Create new object store without keyPath (using out-of-line keys)
        db.createObjectStore('media');
      };
    }
    
    // File upload setup
    function setupFileUpload() {
      const uploadBox = document.getElementById('upload-box');
      const fileInput = document.getElementById('file-input');
      const zipInput = document.getElementById('zip-input');
      
      // Drag and drop
      uploadBox.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadBox.classList.add('dragover');
      });
      
      uploadBox.addEventListener('dragleave', () => {
        uploadBox.classList.remove('dragover');
      });
      
      uploadBox.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadBox.classList.remove('dragover');
        
        const files = Array.from(e.dataTransfer.files);
        if (files.length > 0) {
          const zipFile = files.find(f => f.name.endsWith('.zip'));
          if (zipFile) {
            handleZipFile(zipFile);
          } else {
            handleDirectory(files);
          }
        }
      });
      
      // File inputs
      fileInput.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
          handleDirectory(Array.from(e.target.files));
        }
      });
      
      zipInput.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
          handleZipFile(e.target.files[0]);
        }
      });
    }
    
    // Handle ZIP file
    async function handleZipFile(file) {
      showLoading();
      
      try {
        const zip = await JSZip.loadAsync(file);
        const files = {};
        
        // Extract all files
        for (const [path, zipEntry] of Object.entries(zip.files)) {
          if (!zipEntry.dir) {
            const blob = await zipEntry.async('blob');
            files[path] = new File([blob], zipEntry.name, { type: blob.type });
          }
        }
        
        await processFiles(Object.values(files));
      } catch (error) {
        console.error('ZIP error:', error);
        alert('ZIP dosyasƒ± okunamadƒ±: ' + error.message);
        hideLoading();
      }
    }
    
    // Handle directory
    async function handleDirectory(files) {
      showLoading();
      await processFiles(files);
    }
    
    // Process files
    async function processFiles(files) {
      try {
        // Find chat file
        const chatFile = files.find(f => f.name === '_chat.txt');
        if (!chatFile) {
          throw new Error('_chat.txt dosyasƒ± bulunamadƒ±');
        }
        
        // Parse chat
        const chatText = await chatFile.text();
        const parsed = parseChatFile(chatText);
        messages = parsed.messages;
        
        // Determine first sender (user)
        if (messages.length > 0) {
          firstSender = messages[0].sender;
        }
        
        // Store media files
        const mediaMap = new Map();
        for (const file of files) {
          if (file.name !== '_chat.txt') {
            mediaMap.set(file.name, file);
          }
        }
        
        // Store in IndexedDB
        await storeMediaFiles(mediaMap);
        
        // Show chat
        showChat();
        renderMessages();
      } catch (error) {
        console.error('Process error:', error);
        alert('Hata: ' + error.message);
        hideLoading();
      }
    }
    
    // Parse chat file
    function parseChatFile(text) {
      const lines = text.split('\n');
      const messages = [];
      let currentMessage = null;
      
      const dateRegex = /^\[(\d{1,2}\/\d{1,2}\/\d{2,4})\s+(\d{1,2}:\d{2}:\d{2})\]\s+(.+?):\s*(.+)$/;
      // More flexible media regex - handles invisible characters and various formats
      const mediaRegex = /[<‚Äé<]?\s*([^>\s]+\.(jpg|jpeg|png|gif|webp|opus|mp3|wav|m4a|pdf|vcf|xlsx|xls|doc|docx))\s+eklendi[>]?/i;
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        const dateMatch = line.match(dateRegex);
        
        if (dateMatch) {
          // Save previous message
          if (currentMessage) {
            messages.push(currentMessage);
          }
          
          // New message
          const [, date, time, sender, content] = dateMatch;
          // Clean content from invisible characters
          const cleanContent = content.replace(/[\u200E\u200F\u202A-\u202E]/g, '').trim();
          const mediaMatch = cleanContent.match(mediaRegex);
          
          let mediaFileName = null;
          if (mediaMatch) {
            mediaFileName = mediaMatch[1].trim();
          }
          
          currentMessage = {
            date: parseDate(date),
            time: time,
            sender: sender.trim(),
            text: mediaFileName ? '' : cleanContent,
            media: mediaFileName,
            timestamp: new Date(parseDate(date) + ' ' + time)
          };
        } else if (currentMessage) {
          // Continuation of previous message - check for media in continuation
          const mediaMatch = line.match(mediaRegex);
          if (mediaMatch) {
            currentMessage.media = mediaMatch[1].trim();
            currentMessage.text = '';
          } else {
            currentMessage.text += '\n' + line;
          }
        }
      }
      
      // Add last message
      if (currentMessage) {
        messages.push(currentMessage);
      }
      
      return { messages };
    }
    
    // Parse date
    function parseDate(dateStr) {
      const parts = dateStr.split('/');
      if (parts.length === 3) {
        const month = parts[0].padStart(2, '0');
        const day = parts[1].padStart(2, '0');
        const year = parts[2].length === 2 ? '20' + parts[2] : parts[2];
        return `${year}-${month}-${day}`;
      }
      return dateStr;
    }
    
    // Store media files in IndexedDB
    async function storeMediaFiles(filesMap) {
      if (!db) {
        await new Promise(resolve => {
          const checkDb = setInterval(() => {
            if (db) {
              clearInterval(checkDb);
              resolve();
            }
          }, 100);
        });
      }
      
      // Process files in batches to avoid transaction timeout
      const batchSize = 10;
      const entries = Array.from(filesMap.entries());
      
      for (let i = 0; i < entries.length; i += batchSize) {
        const batch = entries.slice(i, i + batchSize);
        
        // Create promises for each file in batch
        const promises = batch.map(async ([name, file]) => {
          try {
            // Read file as array buffer first
            const arrayBuffer = await file.arrayBuffer();
            
            // Then store in IndexedDB with separate transaction
            return new Promise((resolve, reject) => {
              const transaction = db.transaction(['media'], 'readwrite');
              const store = transaction.objectStore('media');
              
              // Store with explicit key (out-of-line key)
              const request = store.put(arrayBuffer, name);
              
              request.onsuccess = () => {
                mediaFiles.set(name, { name, type: file.type, size: file.size });
                resolve();
              };
              
              request.onerror = () => {
                console.error(`Error storing ${name}:`, request.error);
                // Continue even if one file fails
                resolve(); // Don't reject, just continue
              };
            });
          } catch (error) {
            console.error(`Error storing ${name}:`, error);
            // Continue with other files even if one fails
          }
        });
        
        // Wait for batch to complete
        await Promise.all(promises);
      }
    }
    
    // Get media from IndexedDB
    async function getMediaFile(fileName) {
      if (!db) return null;
      
      // Clean filename from any invisible characters
      const cleanFileName = fileName.replace(/[\u200E\u200F\u202A-\u202E]/g, '').trim();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(['media'], 'readonly');
        const store = transaction.objectStore('media');
        
        // Try exact match with cleaned filename first
        let request = store.get(cleanFileName);
        
        request.onsuccess = () => {
          if (request.result) {
            resolve(new Blob([request.result]));
          } else {
            // Try with original filename
            const originalRequest = store.get(fileName);
            originalRequest.onsuccess = () => {
              if (originalRequest.result) {
                resolve(new Blob([originalRequest.result]));
              } else {
                // Try finding matching key from mediaFiles map
                let foundKey = null;
                for (const key of mediaFiles.keys()) {
                  const cleanKey = key.replace(/[\u200E\u200F\u202A-\u202E]/g, '').trim();
                  if (cleanKey === cleanFileName || key === cleanFileName || 
                      cleanKey.includes(cleanFileName) || cleanFileName.includes(cleanKey)) {
                    foundKey = key;
                    break;
                  }
                }
                
                if (foundKey) {
                  const matchRequest = store.get(foundKey);
                  matchRequest.onsuccess = () => {
                    if (matchRequest.result) {
                      resolve(new Blob([matchRequest.result]));
                    } else {
                      resolve(null);
                    }
                  };
                  matchRequest.onerror = () => resolve(null);
                } else {
                  resolve(null);
                }
              }
            };
            originalRequest.onerror = () => resolve(null);
          }
        };
        
        request.onerror = () => reject(request.error);
      });
    }
    
    // Show chat
    function showChat() {
      document.getElementById('upload-area').classList.add('hidden');
      document.getElementById('chat-area').classList.add('visible');
      
      // Set chat title
      const chatTitle = document.getElementById('chat-title');
      if (messages.length > 0) {
        const senders = [...new Set(messages.map(m => m.sender))];
        chatTitle.textContent = senders.join(', ');
      }
      
      // Set chat info
      document.getElementById('chat-info').textContent = 
        `${messages.length} mesaj`;
    }
    
    // Render messages with virtual scrolling
    let visibleStart = 0;
    let visibleEnd = 100;
    const itemsPerPage = 100;
    let container = null;
    
    function renderMessages() {
      container = document.getElementById('messages-container');
      container.innerHTML = '';
      
      // Reset virtual scrolling
      visibleStart = 0;
      visibleEnd = Math.min(itemsPerPage, messages.length);
      
      // Render ALL messages - no virtual scrolling, no date filtering
      // Always render all messages to ensure nothing is missing
      visibleStart = 0;
      visibleEnd = messages.length;
      renderMessageBatch(0, messages.length);
      
      // Scroll to bottom after render
      setTimeout(() => {
        container.scrollTo({
          top: container.scrollHeight,
          behavior: 'auto'
        });
      }, 100);
    }
    
    function renderMessageBatch(start, end) {
      const fragment = createMessageFragment(start, end);
      container.appendChild(fragment);
    }
    
    function createMessageFragment(start, end) {
      const fragment = document.createDocumentFragment();
      let lastDate = null;
      
      for (let i = start; i < end && i < messages.length; i++) {
        const message = messages[i];
        
        // Date separator
        const messageDate = message.date;
        if (messageDate !== lastDate) {
          const separator = document.createElement('div');
          separator.className = 'date-separator';
          const dateText = document.createElement('span');
          dateText.className = 'date-text';
          dateText.textContent = formatDate(messageDate);
          separator.appendChild(dateText);
          fragment.appendChild(separator);
          lastDate = messageDate;
        }
        
        // Message group
        const group = document.createElement('div');
        group.className = 'message-group';
        
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble';
        
        // Determine if sent or received
        const isSent = firstSender && message.sender === firstSender;
        bubble.classList.add(isSent ? 'sent' : 'received');
        
        // Sender name (if group chat and received)
        const senders = [...new Set(messages.map(m => m.sender))];
        if (senders.length > 2 && !isSent) {
          const senderEl = document.createElement('div');
          senderEl.className = 'message-sender';
          senderEl.textContent = message.sender;
          bubble.appendChild(senderEl);
        }
        
        // Message text
        if (message.text) {
          const textEl = document.createElement('div');
          textEl.className = 'message-text';
          // Basic link detection
          const text = message.text.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" style="color: #53bdeb;">$1</a>');
          textEl.innerHTML = text;
          bubble.appendChild(textEl);
        }
        
        // Media (async, will be added)
        if (message.media) {
          const mediaContainer = document.createElement('div');
          bubble.appendChild(mediaContainer);
          // Add loading placeholder
          mediaContainer.innerHTML = '<div style="color: #8696a0; font-size: 12px; padding: 8px;">Y√ºkleniyor...</div>';
          // Render media asynchronously
          renderMedia(mediaContainer, message.media).catch(err => {
            console.error('Error rendering media:', err);
            mediaContainer.innerHTML = '<div style="color: #8696a0; font-size: 12px; padding: 8px;">Medya y√ºklenemedi</div>';
          });
        }
        
        // Time
        const timeEl = document.createElement('div');
        timeEl.className = 'message-time';
        timeEl.textContent = message.time;
        bubble.appendChild(timeEl);
        
        group.appendChild(bubble);
        fragment.appendChild(group);
      }
      
      return fragment;
    }
    
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }
    
    // Render media
    async function renderMedia(container, fileName) {
      // Clean filename from any invisible characters
      const cleanFileName = fileName.replace(/[\u200E\u200F\u202A-\u202E]/g, '').trim();
      
      // Try exact match first
      let mediaInfo = mediaFiles.get(cleanFileName);
      
      // If not found, try to find by partial match (in case of encoding issues)
      if (!mediaInfo) {
        for (const [key, value] of mediaFiles.entries()) {
          if (key.includes(cleanFileName) || cleanFileName.includes(key)) {
            mediaInfo = value;
            break;
          }
        }
      }
      
      if (!mediaInfo) {
        container.innerHTML = '<div style="color: #8696a0; font-size: 12px; padding: 8px;">Medya bulunamadƒ±: ' + cleanFileName + '<br><small>Dosya adƒ±: ' + fileName + '</small></div>';
        console.warn('Media not found:', cleanFileName, 'Available files:', Array.from(mediaFiles.keys()).slice(0, 10));
        return;
      }
      
      const preview = document.createElement('div');
      preview.className = 'media-preview';
      
      const ext = fileName.split('.').pop().toLowerCase();
      
      if (['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(ext)) {
        // Image
        try {
          const blob = await getMediaFile(cleanFileName);
          if (blob) {
            const url = URL.createObjectURL(blob);
            const img = document.createElement('img');
            img.src = url;
            img.alt = cleanFileName;
            img.loading = 'lazy';
            img.style.display = 'block';
            img.style.width = '100%';
            img.style.maxWidth = '300px';
            img.style.height = 'auto';
            preview.appendChild(img);
            preview.onclick = () => showMediaModal(cleanFileName, 'image', url);
            container.innerHTML = ''; // Clear loading message
            container.appendChild(preview);
          } else {
            container.innerHTML = '<div style="color: #8696a0; font-size: 12px; padding: 8px;">Resim y√ºklenemedi: ' + cleanFileName + '<br><small>Mevcut dosyalar: ' + Array.from(mediaFiles.keys()).slice(0, 3).join(', ') + '</small></div>';
            console.error('Image not found in IndexedDB:', cleanFileName);
            return;
          }
        } catch (error) {
          console.error('Error loading image:', error);
          container.innerHTML = '<div style="color: #8696a0; font-size: 12px; padding: 8px;">Resim hatasƒ±: ' + error.message + '</div>';
          return;
        }
      } else if (ext === 'opus' || ext === 'mp3' || ext === 'wav' || ext === 'm4a') {
        // Audio
        preview.className += ' audio';
        preview.innerHTML = `
          <div class="media-icon">üéµ</div>
          <div class="media-info">
            <div class="media-name">Ses Mesajƒ±</div>
            <div class="media-size">${formatFileSize(mediaInfo.size)}</div>
          </div>
        `;
        preview.onclick = () => showMediaModal(fileName, 'audio');
        container.innerHTML = ''; // Clear loading message
        container.appendChild(preview);
      } else if (ext === 'pdf') {
        // PDF
        preview.className += ' file';
        const shortName = fileName.length > 30 ? fileName.substring(0, 27) + '...' : fileName;
        preview.innerHTML = `
          <div class="media-icon">üìÑ</div>
          <div class="media-info">
            <div class="media-name">${shortName}</div>
            <div class="media-size">${formatFileSize(mediaInfo.size)}</div>
          </div>
        `;
        preview.onclick = () => showMediaModal(fileName, 'pdf');
        container.innerHTML = ''; // Clear loading message
        container.appendChild(preview);
      } else if (ext === 'vcf') {
        // VCF
        preview.className += ' file';
        preview.innerHTML = `
          <div class="media-icon">üë§</div>
          <div class="media-info">
            <div class="media-name">ƒ∞leti≈üim Kartƒ±</div>
            <div class="media-size">${fileName}</div>
          </div>
        `;
        preview.onclick = () => showMediaModal(fileName, 'vcf');
        container.innerHTML = ''; // Clear loading message
        container.appendChild(preview);
      } else if (['xlsx', 'xls', 'doc', 'docx'].includes(ext)) {
        // Office files
        preview.className += ' file';
        const shortName = fileName.length > 30 ? fileName.substring(0, 27) + '...' : fileName;
        preview.innerHTML = `
          <div class="media-icon">üìä</div>
          <div class="media-info">
            <div class="media-name">${shortName}</div>
            <div class="media-size">${formatFileSize(mediaInfo.size)}</div>
          </div>
        `;
        preview.onclick = () => showMediaModal(fileName, 'file');
      } else {
        // Other files
        preview.className += ' file';
        const shortName = fileName.length > 30 ? fileName.substring(0, 27) + '...' : fileName;
        preview.innerHTML = `
          <div class="media-icon">üìé</div>
          <div class="media-info">
            <div class="media-name">${shortName}</div>
            <div class="media-size">${formatFileSize(mediaInfo.size)}</div>
          </div>
        `;
        preview.onclick = () => showMediaModal(fileName, 'file');
        container.innerHTML = ''; // Clear loading message
        container.appendChild(preview);
      }
    }
    
    // Show media modal
    async function showMediaModal(fileName, type, imageUrl = null) {
      const modal = document.getElementById('media-modal');
      const content = document.getElementById('modal-content');
      content.innerHTML = '';
      
      if (type === 'image' && imageUrl) {
        const img = document.createElement('img');
        img.src = imageUrl;
        content.appendChild(img);
      } else if (type === 'audio') {
        const blob = await getMediaFile(fileName);
        if (blob) {
          const url = URL.createObjectURL(blob);
          const audio = document.createElement('audio');
          audio.controls = true;
          audio.src = url;
          audio.style.width = '100%';
          audio.style.minWidth = '300px';
          audio.style.maxWidth = '600px';
          
          // Fallback message for unsupported formats
          const info = document.createElement('div');
          info.style.color = '#8696a0';
          info.style.fontSize = '12px';
          info.style.marginTop = '10px';
          info.style.textAlign = 'center';
          info.textContent = 'Tarayƒ±cƒ±nƒ±z bu ses formatƒ±nƒ± desteklemiyorsa, dosyayƒ± indirip ba≈üka bir uygulamada a√ßabilirsiniz.';
          
          const downloadLink = document.createElement('a');
          downloadLink.href = url;
          downloadLink.download = fileName;
          downloadLink.textContent = 'Ses Dosyasƒ±nƒ± ƒ∞ndir';
          downloadLink.style.display = 'block';
          downloadLink.style.color = '#53bdeb';
          downloadLink.style.padding = '10px';
          downloadLink.style.marginTop = '10px';
          downloadLink.style.textAlign = 'center';
          downloadLink.style.textDecoration = 'underline';
          
          content.appendChild(audio);
          content.appendChild(info);
          content.appendChild(downloadLink);
        }
      } else if (type === 'pdf') {
        const blob = await getMediaFile(fileName);
        if (blob) {
          const url = URL.createObjectURL(blob);
          // Try iframe first (works in most browsers)
          const iframe = document.createElement('iframe');
          iframe.src = url + '#toolbar=0';
          iframe.style.width = '90vw';
          iframe.style.height = '90vh';
          iframe.style.border = 'none';
          content.appendChild(iframe);
          
          // Fallback: download link
          const downloadLink = document.createElement('a');
          downloadLink.href = url;
          downloadLink.download = fileName;
          downloadLink.textContent = 'PDF\'yi ƒ∞ndir';
          downloadLink.style.display = 'block';
          downloadLink.style.color = 'white';
          downloadLink.style.padding = '10px';
          downloadLink.style.marginTop = '10px';
          downloadLink.style.textAlign = 'center';
          downloadLink.style.background = 'rgba(255,255,255,0.1)';
          downloadLink.style.borderRadius = '8px';
          content.appendChild(downloadLink);
        }
      } else if (type === 'vcf') {
        const blob = await getMediaFile(fileName);
        if (blob) {
          const text = await blob.text();
          const pre = document.createElement('pre');
          pre.style.color = 'white';
          pre.style.padding = '20px';
          pre.textContent = text;
          content.appendChild(pre);
        }
      } else {
        // Download link
        const blob = await getMediaFile(fileName);
        if (blob) {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = fileName;
          a.textContent = 'ƒ∞ndir: ' + fileName;
          a.style.color = 'white';
          a.style.padding = '20px';
          a.style.display = 'block';
          content.appendChild(a);
          a.click();
        }
      }
      
      modal.classList.add('active');
    }
    
    // Close media modal
    function closeMediaModal() {
      const modal = document.getElementById('media-modal');
      modal.classList.remove('active');
      const content = document.getElementById('modal-content');
      content.innerHTML = '';
    }
    
    // Format date
    function formatDate(dateStr) {
      const date = new Date(dateStr);
      const today = new Date();
      const yesterday = new Date(today);
      yesterday.setDate(yesterday.getDate() - 1);
      
      if (dateStr === formatDateStr(today)) {
        return 'Bug√ºn';
      } else if (dateStr === formatDateStr(yesterday)) {
        return 'D√ºn';
      } else {
        return date.toLocaleDateString('tr-TR', { 
          day: 'numeric', 
          month: 'long', 
          year: 'numeric' 
        });
      }
    }
    
    function formatDateStr(date) {
      return date.toISOString().split('T')[0];
    }
    
    // Format file size
    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
    }
    
    // Show loading
    function showLoading() {
      document.getElementById('upload-area').classList.add('hidden');
      document.getElementById('chat-area').classList.add('visible');
      document.getElementById('messages-container').innerHTML = `
        <div class="loading">
          <div class="spinner"></div>
          <span>Y√ºkleniyor...</span>
        </div>
      `;
    }
    
    // Hide loading
    function hideLoading() {
      // Will be replaced by renderMessages
    }
    
    // Reset app
    function resetApp() {
      messages = [];
      mediaFiles.clear();
      firstSender = null;
      visibleStart = 0;
      visibleEnd = 100;
      document.getElementById('upload-area').classList.remove('hidden');
      document.getElementById('chat-area').classList.remove('visible');
      
      // Clear IndexedDB
      if (db) {
        const transaction = db.transaction(['media'], 'readwrite');
        const store = transaction.objectStore('media');
        store.clear();
      }
    }
    
    // Close modal on escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeMediaModal();
      }
    });
    
    // Close modal on background click
    document.getElementById('media-modal').addEventListener('click', (e) => {
      if (e.target.id === 'media-modal') {
        closeMediaModal();
      }
    });
    
  </script>
</body>
</html>

